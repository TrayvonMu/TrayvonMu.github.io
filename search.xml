<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1111]]></title>
    <url>%2Fposts%2Fdbf9c8f7.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[信息收集]]></title>
    <url>%2Fposts%2F312e3d12.html</url>
    <content type="text"><![CDATA[1.收集域名信息DNS、注册人、备案等有关域名的一切信息。 收集方式Whois：站长之家，爱站网等； 备案：天眼查、ICP备案查询网等； 敏感字收集：Google Google用法 Site ————指定域名 Inurl————URL中的关键字 Intext———-网页正文中的关键字 Filetype——-指定的文件类型 Intitle———-网页标题中的关键字 link————-link:baidu.com表示有和baidu.com连接的URL Info ————查找指定站点的基本信息 Cache———-搜索Google里有关某些内容的缓存 例：site: edu.cn intext: 后台管理 子域名信息收集Layer子域名挖掘机等 扫描端口扫描端口：Nmap，无状态端口扫描工具Masscan，御剑高速TCP端口扫描工具等 常见的端口信息 端口 端口说明 攻击方向 文件共享服务端口： 21/22/69 Ftp/Tftp文件传输协议 允许匿名上传、下载、爆破和嗅探操作 2049 Nfs服务 配置不当 139 Samba服务 爆破、未经授权访问、远程代码执行 389 Ldap目录访问协议 注入、允许匿名访问、弱口令 远程链接服务端口： 22 SSH远程链接 爆破、SSH隧道及内网代理转发、文件传输 23 Telnet远程连接 爆破、嗅探、弱口令 3398 Rdp远程桌面连接 爆破、嗅探、弱口令 Server 2003以下的系统)、爆破： 5900 VNC 弱口令、爆破 5632 PyAnywhere服务 抓密码、代码执行 Web应用服务端口： 80/443/8080 常见的Web服务端口 Web攻击、爆破对应服务版本的漏洞 7001/7002 WebLogic控制台 Java反序列化、弱口令 8080/8089 Jboss/Resin/Jetty/Jenkins 反序列化控制台弱口令 9090 WebSphere控制台 Java反序列化、弱口令 4848 GlassFish控制台 弱口令 1352 Lotus domino邮电服务 弱口令、信息泄露、爆破 10000 Webmin-Web控制面板 弱口令 数据库服务端口： 3306 MYSQL 注入、提权、爆破 1433 MSSQL 注入、提权、SA弱口令、爆破 1521 Oracle数据库 TNS爆破、注入、反弹Shell 5432 PostgreSQL数据库 爆破、注入、弱口令 27017/27018 MongoDB数据库 爆破、未授权访问 6379 Redis数据库 可尝试未授权访问、弱口令 5000 SysBase/DB2数据库 可尝试未授权访问、弱口令 邮件服务端口： 25 SMTP邮件服务 邮件伪造 110 POP3协议 爆破、嗅探 143 IMAP协议 爆破 网络常见协议端口： 53 DNS域名系统 允许区域传送、DNS劫持、缓存投毒、欺骗 67/68 DHCP服务 劫持、欺骗 161 SNMP协议 爆破、搜索目标内网信息 特殊服务端口： 2181 Zookeeper服务 未经授权访问 8069 zabbix服务 远程执行、SQL注入 9200/9300 Elasticsearch服务 远程执行 11211 Memcache服务 未经授权 512/513/514 Linux Rexec服务 爆破、Rlogin登陆 873 Rsync服务 匿名访问、文件上传 3690 Svn服务 Svn泄露、未经授权访问 50000 SAP Management Console 远程执行 2.指纹识别是指自动识别网址所用的CMS，常见的CMS有Dedecms(织梦)、Discuz、PHPWEB、PHPWind、PHPCMS、ECShop、Dvbbs、SiteWeaver、ASPCMS、帝国、Z-Blog、WordPress 常见的指纹识别工具御剑Web指纹识别、WhatWeb、WebRobo、椰树、轻量级WEB指纹识别等 在线指纹识别网址 BugScaner：http://whatweb.bugscaner.com/look/ 云悉指纹：http://www.yunsee.cn/finger.html WhatWeb：http://whatweb.net/ 3.查找真实的IP在渗透过程中，目标服务可能只有一个域名。那么如何听过这个域名来确定目标服务器的真实IP对渗透测试来说就很重要。如果目标服务器不存在CDN，壳直接通过www.ip138.com获取目标的一些IP及域名信息。这里主要是讲在一下这几种情况下，如何绕过CDN寻找目标服务器的真实IP。 目标服务器存在CDN如果目标存在CDN则我们ping目标的域名时得到的并非真正的Web服务器，只是离我们最近的一台目标节点的CDN服务器。 判断是否使用了CDN可以通过ping目标主域，观察域名解析的情况来判断还可以利用在线网址（17CE.com）进行全国多地区的ping服务器操作，然后对比各个地区ping出的IP结果判断，查看这些IP是否一致，如果一样的，极有可能不存在CDN，如果不太一样或者规律很强，可以尝试查找这些IP的归属地，判断是否存在CDN。 绕过CDN寻找真实的IP内部邮箱：查看邮件、寻找邮件头中的邮件服务器IPping邮箱的域名（邮箱必须是自己的邮件服务器），通过网站用户注册或者RSS订阅。 扫描网站的测试文件：如phpinfo、test等。 分站域名：可以通过ping二级域名来获取分站IP，可能会出现分站和主站不在同一个IP下但是在同一个C段下。 国外访问：国内的CDN往往支队国内用户的访问加速，而国外的CDN就不一定了。因此，通过国外在线代理网址App Svnthetic Monitor(https://asm.ca.com/en/ping.php)访问，可能会得到真实的IP。 查询域名解析记录：https://www.netcraft.com。 网址自己的APP：是可以尝试利用Fiddler或Burp Suit抓取App的请求，从里面找到真实的IP。 验证获取的IP直接用IP访问或者在目标段比较打的情况下，借助类似Masscan的工具批量扫描对应IP段中所有开了80.443.8080端口的IP。然后珠峰尝试IP访问观察相应结果是否为主站点。]]></content>
      <tags>
        <tag>web</tag>
        <tag>信息收集</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读书目推荐]]></title>
    <url>%2Fposts%2F4f45247d.html</url>
    <content type="text"><![CDATA[写在前面:​ 平时一直有读书的习惯，去年大概读有87本书，一直没有去做产出和推荐，但每一本书多多少少都做有读书笔记,这带来的帮助超乎了我的预料。 ​ 既然老师上次提出了可以推荐书目的建议，我也觉得多读书确实大有裨益。绝不限于是课内书本以及专业课本，更希望能去广泛去涉猎经济，文化，政治等类目的书籍，会让我们更宏观且全面的去了解这个世界和社会中的既成规则以及现象，深入的了解自己。 ​ 这个事情我会根据我的阅读进度，不定期给大家进行更新推荐，也算是对我自己的一个勉励。 2019/4/1-2019/4/19​ 在此期间我看了大概有四本书吧，有的一部分书是高质量精读过去的： 《沉思录》——[古罗马]马可·奥勒留 《从0到1开启商业与未来的秘密》——[美]彼得·蒂尔 《大数据 : 正在到来的数据革命，以及它如何改变政府、商业与我们的生活》——[中]涂子沛 《爱与黑暗的故事》——[以色列] 阿摩司·奥兹 推荐书目： 1 《沉思录》 2 《从0到1开启商业与未来的秘密》 3 《大数据 : 正在到来的数据革命，以及它如何改变政府、商业与我们的生活》 推荐理由： ​ 简短几句话说一下推荐理由: 《沉思录》是古罗马皇帝奥勒留写给自己的书，内容大部分是他在鞍马劳顿中写成的。作品来自奥勒留对身羁宫廷的自己和自己所处混乱世界的感受，追求一种冷静而达观的生活。这部著作是斯多葛学派的一个里程碑。作品中处处反映出很多对于人生的感悟，引人深思，去追问内心和探索本我。其虽然成书于近两千年前的古罗马时期，但其中的内容时至今日都感觉内容深刻而富有哲理，适用于当今时代社会。 Paypal创始人，Facebook第一位外部投资者彼得•蒂尔在本书中详细阐述了自己的创业历程与心得，包括如何避免竞争、如何进行垄断、如何发现新的市场。《从0到1》还将带你穿越哲学、历史、经济等多元领域，解读世界运行的脉络，分享商业与未来发展的逻辑，帮助你思考从0到1的秘密，在意想不到之处发现价值与机会。对于无论是否有创业想法的我们开阔眼界都有很大的帮助。 本书通过讲述美国半个多世纪信息开放、技术创新的历史，以别开生面的经典案例——奥巴马建设“前所未有的开放政府”的雄心、公共财政透明的曲折、《数据质量法》背后的隐情、全民医改法案的波澜、统一身份证的百年纠结、街头警察的创新传奇、美国矿难的悲情历史、商务智能的前世今生、数据开放运动的全球兴起，以及云计算、Facebook和推特等社交媒体、Web3.0与下一代互联网的未来图景等等，为您一一细解，数据创新给公民、政府、社会带来的种种挑战和变革。 美国是全书主体，但又处处反观中国当下的现实。回望中国，胡适批评“差不多先生”，黄仁宇求索“数目字管理”，作者从太平洋对面看到中美两国的差距，深知中国缺少什么、需要什么，故将十多年观察、思索所得，淘洗成这一本书。 史学大家、匹兹堡大学历史系荣誉讲座教授许倬云，有感于“老大哥”的影子，专门作序：“我们要对涂子沛先生致敬与致谢，因为他为华文世界提出一个重要的话题。” 哈佛大学商学院访问教授、全球顶尖的管理咨询大师达文波特，为中国政经两界提示智库建言：“无论是对中国政府，还是就中国的商业组织而言，《大数据》都是一本重要的书。” ​ 最后说一下为什么没有推荐第四本书，《爱与黑暗的故事》这本书讲述的是百余年间一个犹太家族的历史与民族叙事，文笔很棒，但出于文化的差异，对于以色列文化以及当时的时代背景自己缺乏一定的了解，以至于在阅读的时候有很多的不理解和提不起兴趣，缺乏知识共鸣，但作者的文笔和作品底蕴在世界上都是一流的，后期有补充犹太史和以色列文化的打算，再来拜读这本书，此前有这些基础的同学很推荐阅读这本书。 2019/4/19-2019/5/15​ 最近一直忙于做几个比赛，前期比赛准备和谈企业合作，显得过于忙碌。但结果还算不错，一个项目在三创拿到了校一等并进入了省赛。互联网+的项目，也在院赛中取得了第2和第34的排名，这在报进来370个队伍中也实属不易吧。废话不多说，言归正传进入正题： 《中国禅宗史》——[中]印顺 《人间瓷话》——[中]钱汉东 《美好人生运营指南》——[中]一稼 《贫穷的本质》——[美]阿比吉特•班纳吉 推荐书目： 1 《人间瓷话》 2 《中国禅宗史》 3 《贫穷的本质》 推荐理由： 一次偶然巧合的机会，在项目组工作室碰到了本院通工专业的李同学，他在组里用傅里叶变换红外光谱仪做农残鉴定，在回西区的路上谈起专业方面的知识，了解到他家里是做瓷器鉴定方面的工作已久，算是相谈甚欢。回到宿舍他给我推荐的这本关于瓷器入门科普性质的书籍《人间瓷话》，直接借用书中大概的简介来介绍：作者对中国的主要窑口和代表性瓷种都作了深入浅出的介绍，这对初学陶瓷者很有帮助，即使那些从事古陶瓷收藏的朋友也会从中得到某些启发，它可以帮助我们进一步认识陶瓷器的文化历史和艺术价值，从美学的角度来审视古陶瓷，从中感受到中华文化的博大和精深。 关于宗教这方面的书，也是感谢本学院通工李同学的推荐借阅，具体到《中国禅宗史》这本书，本来这方面的书自己接触的不算很多，在阅读的时候深为印顺法师的学者文风所叹服。印顺法师重逻辑，重史实，他的著作无论对佛教界，学术界都有重大影响，作为一般读物也大有脾益，极力推荐。 这本书主要是由两位专门研究扶贫项目的两位美国经济学家，在十八个国家针对每天收入少于一美元的赤贫人口进行深度调研和扶贫支援后写就的。虽然这是一本经济学书籍，但是篇幅不长并且专业知识要求的不多，读起来并不吃力，但内容庞杂、涵盖面广，阅读时要有一定的专注力。 ​ 提及的内容有：贫穷陷阱、健康陷阱、教育问题、人口问题、慈善和贷款、穷人创业、工作问题和政府政策问题。贫穷陷阱和健康陷阱是穷人难以摆脱贫穷的最大问题。穷困者一旦超过贫困和健康状况的警戒线，就等于进入了贫穷的无底洞，陷入贫穷陷阱，想挣脱出来难乎其难。 ​ 而对穷困者进行的健康、子女教育、生育保健、存款、慈善等方面的工作往往很难收到成效。鼓励穷困者创业的小额贷款一度颇有成效，但由于贷款额度小、长期管理耗费精力，再加上穷困者对贷款的信心经常受到谣言的干扰，那些致力于小额贷款的银行家至今仍在艰难地探索中。 ​ 究其原因，作者认为是由于穷困者缺乏信息来源而且负担繁重，服务于穷困者的市场也在逐渐消失。而贫穷国家和地区政权腐败、无意服务于人民是造成广泛贫穷的重要原因。 那本《美好人生运营指南》就不再推荐了，一个远方的朋友给我寄来的一本书，纯鸡汤文，闻起来都是一个味道，吃起来也是只有汤没有肉，个人的原因，读来感觉兴趣不大，没看完也没打算继续看下去了。 2019/5/15-]]></content>
      <tags>
        <tag>书籍推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在http层通过header请求头伪造ip]]></title>
    <url>%2Fposts%2F56dbd93c.html</url>
    <content type="text"><![CDATA[前言在正常的tcp/ip协议中是很难伪造ip的，因为在tcp/ip正式通信之前是有一个三次握手的过程，通过三次握手建立了tcp/ip连接之后再进行正常的通信，所以我之前想用python的scapy库来伪造其他ip的请求包，但是因为三次握手的时候，我的ip是伪造的，我发出去的请求包就没有办法正确的返回找到我，所以无法三次握手就没有tcp/ip正常通信，就失败了。 只要能够在tcp/ip层伪造ip，就是完全的伪造ip，没有任何办法判断，不过我这次的是在http层伪造ip，所以还是可能被发现的，而且也只有在http协议中有用，无法利用在其他地方。 header那么如何在http层伪造协议呢？我们先来了解一些http请求中的请求头header，比如说我们在chrome中登陆百度，打开chrome的开发者工具，查看network，就能够看到这次请求百度的header请求头。 Requests Headers 12345678Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding:gzip, deflate, sdchAccept-Language:zh-CN,zh;q=0.8Connection:keep-aliveCookie:BIDUPSID=XXX; PSTM=XXX; BAIDUID=XXX:FG=1; BDUSS=XXX; __cfduid=XXX; ispeed_lsm=2; BD_HOME=1; BDRCVFR[Ups602knC30]=XXX; BD_CK_SAM=1; H_PS_PSSID=XXX; BD_UPN=XXX; H_PS_645EC=XXX; locale=XXX; BDSVRTM=0; BD_LAST_QID=XXXHost:www.baidu.comUpgrade-Insecure-Requests:1User-Agent:Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/49.0.2623.108 Chrome/49.0.2623.108 Safari/537.36 可以看到这里有很多的请求参数，在我们打开百度的时候，我们先要向百度服务器发送一个请求，而这个请求包含很多附加的关于我们自己的信息，比如说浏览器信息，cookie，接受数据格式等等，百度服务器收到我们的请求之后，返回给我们百度的页面。 在我们发送http请求之前，就已经先进行了tcp/ip三次握手，然后再发送http请求，三次握手的过程是非常迅速的，可以用抓包工具 wireshark 查看。 所以 header 请求头主要是一些我们发送请求时附带的我们自己的信息，同时，在看到 header 请求头的时候，也会发现在服务器返回数据的时候也会带有一个 header ，这是返回数据格式的一些信息，包括返回数据的格式，大小，时间等。 可尝试各种伪造IP的HTTP头： 12345X-Forwarded-ForClient-IPx-remote-IPx-originating-IPx-remote-addr X-Forwarded-For接下来就是我们伪造ip的核心了，header 请求头中的 X-Forwarded-For 参数 ，这是一个用来识别http代理或负载平衡的原始ip的一个非rfc标准，就是在http请求中有时会使用代理，或者是负载均衡的时候通过了一个转发，这样的话原始ip就被隐藏起来了，这个参数就是为了标注出原始ip，格式是X-Forwarded-For:client1, proxy1, proxy2 ... 第一个是原始ip，后面是经过的代理。 本来这个参数是挺好的，可以判断你是否经过代理判断原始ip，不过一般使用代理的人不就是为了不被别人发现自己的真实ip么？所以这个参数也没用成为rfc的标准，默认是没有的，不强制添加。 所以这样的话，我们本来没有使用代理，就是真实ip，是不是就可以通过增加一个这样的 header 参数来伪造自己经过了代理呢？然后加入我们伪造的 ip ，让服务器以为它是真实的ip。 这样的一个思路看起来是挺好的，那么接下来我们看一下服务器是如何得到我们的ip的。 服务器如何得到客户ip的在这里以php为例，在php里有三个值保存客户ip，分别是 HTTP_CLIENT_IP,HTTP_X_FORWARDED_FOR,REMOTE_ADDR 。 $_SERVER[&#39;HTTP_CLIENT_IP&#39;] 如果有代理服务器，一般是代理服务器ip，没有则为空$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;] 如果有代理服务器的话，一般是原始ip，没有则为空，若有多个则也显示代理服务器ip $_SERVER[&#39;REMOTE_ADDR&#39;] 如果有代理服务器的话，则为最后一个代理的ip，没有则为连接的客户端ip 可以看到有很多的一般，也就是说前两个都是可以伪造的，最后的一个倒是很难伪造，不过如果真的有代理的话，最后一个也没有什么用。 所以，如何得到真实的客户端ip也是一个很头疼的问题，现在一般的做法是先取得 $_SERVER[&#39;REMOTE_ADDR&#39;] 然后再判断有没有代理，如果有代理则获得原始ip，如果有，则将原始ip作为客户端的ip，比如说采用这种做法的有discuz。 在 discuz 的当前最新版 X3.2 中，可以在 /source/class/discuz/discuz_application.php中找到其获取客户端ip的函数 _get_client_ip ,函数如下。 1234567891011121314private function _get_client_ip() &#123; $ip = $_SERVER['REMOTE_ADDR']; if (isset($_SERVER['HTTP_CLIENT_IP']) &amp;&amp; preg_match('/^([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;$/', $_SERVER['HTTP_CLIENT_IP'])) &#123; $ip = $_SERVER['HTTP_CLIENT_IP']; &#125; elseif(isset($_SERVER['HTTP_X_FORWARDED_FOR']) AND preg_match_all('#\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;#s', $_SERVER['HTTP_X_FORWARDED_FOR'], $matches)) &#123; foreach ($matches[0] AS $xip) &#123; if (!preg_match('#^(10|172\.16|192\.168)\.#', $xip)) &#123; $ip = $xip; break; &#125; &#125; &#125; return $ip;&#125; 也有用这样的函数来取得客户端的ip，不过想法都是一样的，只是实现不一样。 1234567891011function GetIP()&#123; if(!empty($_SERVER["HTTP_CLIENT_IP"])) $cip = $_SERVER["HTTP_CLIENT_IP"] else if(!empty($_SERVER["HTTP_X_FORWARDED_FOR"])) $cip = $_SERVER["HTTP_X_FORWARDED_FOR"] else if(!empty($_SERVER["REMOTE_ADDR"])) $cip = $_SERVER["REMOTE_ADDR"] else $cip = "无法获取！"; return $cip;&#125; 总结测试了一下使用 discuz 的情况，确实是可以伪造ip的，特别是在使用discuz插件投票的时候，可以恶意刷票，不过为了防止这种情况的发生，在服务器端可以通过设置服务器来过滤，这里就不再展开详叙了。 转载出处：通过修改http请求的header请求头来伪造ip By Windard]]></content>
      <tags>
        <tag>web</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YFCTFwriteup]]></title>
    <url>%2Fposts%2F2308731.html</url>
    <content type="text"><![CDATA[YFCTF 部分writeup 但行好事，莫问前程 目标依然存在，把它模糊化成心中一盏明灯，指引前行的北斗星 第一次写正式写writeup，写出已经做出答案题目的writeup，希望自己但凡做一件事都能坚持下去 0x01隐写算是常规套路，折腾了会儿图片发现没什么东西，然后用audacity打开音频文件。适当放大后可以看出来是摩斯密码，使用http://ctf.ssleye.com/解密工具可以直接解密出来。 1flag&#123;jygg&#125; 0x02兵器1024所这是一道流量分析题，先用wireshark打开附件，得到报文： 没有思路的时候从开始逐个点开查看内容，由于主办方的flag为flag{…}的格式，在查看中发现第1，3，5，7的包中恰好有这几个keywords，且全部是request发出的包，所以注重观察request发出的包。 经过对应后，发现将报文中request发出的包中的ttl值当做十进制处理，对应ASCII表后即为所求，得到： 1flag&#123;fkdsjaklvklfnkvhcihvekjndjkschsja&#125; 0x03不安全的上传这道题本来分析报文分析了挺久都没有头绪，以为找的了flag试了下都是错的，在伙伴的提醒下，看了下题目：不安全的上传，结合报文内容找到了与之相关的ftp协议，在窗口顶端过滤栏输入并点击Apply，着重分析ftp协议的内容： 通过对内容观察可知，使用者使用ftp协议进行了两次尝试登录，第一次登录失败，第二次登陆成功，所以flag是第二次登陆信息的可能大一些，进行尝试提交后通过。 1flag&#123;wfjhds$ghrewjgnds%chsjgre&#125; 0x04杂项加密这道题做的时候在尝试理解加密方式，也没查到是哪种加密方式(还是见得太少了)，最后在伙伴的提醒下知道是古典密码的仿射密码： 原理 wiki 仿射密码的加密函数是$$E(x)=(ax+b)(modm)E(x)=(ax+b)(modm)$$其中 xx 表示明文按照某种编码得到的数字 aa 和 mm 互质 mm 是编码系统中字母的数目。 根基观察发现，虽然对于 flag 中的每个字母都加密了 n 次，如果我们仔细分析的话，我们可以发现$$c_1=a_1c+b_1$$ $$c_2=a_2c_1+b_2 =a_1a_2c+a_2b_1+b_2 =kc+d$$ 根据第二行的推导，我们可以得到其实 cncn 也是这样的形式，可以看成 cn=xc+ycn=xc+y ，并且，我们可以知道的是，key 是始终不变化的，所以说，其实这个就是仿射密码。 根据原理利用明文进行攻击： 1234567891011121314151617import gmpykey = '****CENSORED****************'flag = 'TWCTF&#123;*******CENSORED********&#125;'f = open('encrypted', 'r')data = f.read().strip('\n')encrypted = [int(data[i:i + 2], 16) for i in range(0, len(data), 2)]plaindelta = ord(flag[1]) - ord(flag[0])cipherdalte = encrypted[1] - encrypted[0]a = gmpy.invert(plaindelta, 251) * cipherdalte % 251b = (encrypted[0] - a * ord(flag[0])) % 251a_inv = gmpy.invert(a, 251)result = ""for c in encrypted: result += chr((c - b) * a_inv % 251)print result 0x05后记这是自己第二次参加CTF比赛，每一次的比赛中都能真真切切的感受到自己的菜，还是见的太少。自己做出来的题不多，赛后做出的题目由于不知道对错，就没有写出来，题目平台关的这么快有些难受。但好在不断的在朝前走，每一次都能有所收获。下来需要合理安排自己的时间。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weblogic反序列化漏洞初探]]></title>
    <url>%2Fposts%2F669570ad.html</url>
    <content type="text"><![CDATA[Weblogic由WLS Security子组件对外部提供Webservice服务，其中使用了XMLDecoder来解析用户传入的数据，在解析过程中间出现反序列化漏洞，导致可以进行任意命令的执行，由此导致了CVE-2017-3506 &amp; CVE-2017-10271的产生。 0x00 环境准备 Windows 10 x64 Docker CE for Windows IntelliJ IDEA 在Github上的Vulhub是一个面向大众的开源漏洞靶场，因此可以利用现成的Vulhub中的docker-compose.yml进行环境搭建，具体操作步骤可以参照Vulhub相应的描述文件，内容十分详尽，感谢Vulhub大佬们的贡献，为萌新剩下了不少造轮子的时间。 由于需要在宿主机进行本地调试，除了本来打开的7001端口之外，还需要开放一个远端调试端口，所以应该改动一下docker-compose.yml开放8453端口，修改完的内容如下 1234567version: &apos;2&apos;services: weblogic: image: vulhub/weblogic ports: - &quot;7001:7001&quot; - &quot;8453:8453&quot; 启动镜像中间我个人碰到了一些奇怪的问题，导致端口一直打不开，最后发现将配置文件修改如下后，镜像启动正常,很迷。 1234567version: '2'services: weblogic: image: vulhub/weblogic ports: - 7001:7001 - 8453:8453 最后在Docker中docker-compose up -d完成搭建。 Docker搭建完成后，使用命令docker exec -it weblogic bash进入docker容器，修改/root/Oracle/Middleware/user_projects/domains/base_domain/bin/setDomainEnv.sh文件，找到以下代码段 12345if [ "$&#123;debugFlag&#125;" = "true" ] ; then JAVA_DEBUG="-Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,address=$&#123;DEBUG_PORT&#125;,server=y,suspend=n -Djava.compiler=NONE" export JAVA_DEBUG JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; $&#123;enableHotswapFlag&#125; -ea -da:com.bea... -da:javelin... -da:weblogic... -ea:com.bea.wli... -ea:com.bea.broker... -ea:com.bea.sbconsole..." export JAVA_OPTIONS 在其前面添加： 12debugFlag="true"export debugFlag 运行exit退出容器，重启容器。使用命令docker ps查看容器运行情况。 由于要在宿主机远程调试Weblogic，而weblogic是没有源码的，所以需要把相关依赖也一并拷出来。 docker cp weblogic:/root/Oracle/Middleware/wlserver_10.3 ./wlserver_10.3 但会报出如下错误： 1open D:\Docker\vulhub\weblogic\CVE-2017-10271\wlserver_10.3\samples\server\medrec\modules\physician\assembly\target\exploded\physician\physician-jaxrpc-facade-client-broker\WEB-INF\classes\com\bea\physician\facade\broker\jaxrpc\JaxRpcRecordCreationFacadeClientBroker.class: The system cannot find the path specified. 查找结果如下： 由于微软对于命令行下的路径长度限制，拷贝行为会报错并结束。 可以使用linux打包命令：zip -r zipname.zip /targetdir 1zip -r wlserver_10.3.zip /wlserver_10.3 这部分jar包不全，还要将Docker中，/root/Oracle/Middleware/modules给拷出来，然后全部扔进刚才复制到宿主机的wlserver_10.3/server/lib目录下。 0x01 远程调试使用idea打开wlserver_10.3，将server/lib文件夹添加到library。 添加完后，就会发现里面的.jar和.war的包都可以点开了。并且可以搜索里面的一些类和字符串了。然后设置debug，添加一个Remote配置： 端口设置为8453，并且设置module classpath： 点击debug，出现如下字样，说明已经配置ok。 在wlserver_10.3/server/lib/weblogic.jar!/weblogic/wsee/jaxws/WLSServletAdapter.class中的handle方法下断点，看看能否击中断点。 0x02 漏洞复现测试使用的POC如下： 1234567891011121314151617181920212223242526POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: 127.0.0.1:7001Cache-Control: max-age=0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36Upgrade-Insecure-Requests: 1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7Connection: closeContent-Type: text/xmlContent-Length: 769&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/"&gt; &lt;java&gt; &lt;void class="java.lang.ProcessBuilder"&gt; &lt;array class="java.lang.String" length="3"&gt; 。。。。 &lt;void method="start"/&gt; &lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; 对于poc中uri中/wls-wsat/CoordinatorPortType 可以换成CoordinatorPortType11等wsat 这个webservice服务中存在的其他uri。 由于在docker中，就只是利用权限进行了文件写入。 执行的效果图如下： 0x03 动态分析根据poc内容可知，此次漏洞出现在wls-wsat.war中，构造SOAP（XML）格式的请求，在解析的过程中导致XMLDecoder反序列化漏洞 在IDEA中搜索wls-wsat.war。打开后点击web.xml查看有哪些接口 第一个就是所需要的接口。由于WebLogic servlet的分发机制复杂，先放在一边。 根据网上大佬们已有分析，我只是跟一下流程： 从processRequest开始被xml逻辑处理，输入中的readUTF中被反序列化。以下是函数调用栈： 具体分析流程如下：weblogic.wsee.jaxws.WLSServletAdapter.class 请求先会进入handel方法，handel方法又会执行super.handle(var1, var2, var3);方法，这个方法对servlet的容器和request和response进行了封装。 继续跟进 先会对var1的内容判断是否为空，不为空的话，会取出xml中的header，也就是我们poc中的: weblogic.wsee.jaxws.workcontext.WorkContextTube 继续跟进receive() weblogic.workarea.WorkContextMapImpl 将数据传到下一个receiveRequest。 weblogic.workarea.WorkContextLocalMap WorkContextEntryImpl.readEntry(var1)对传进来的数据进行处理，继续跟进 weblogic.workarea.spi.WorkContextEntryImpl 继续跟进WorkContextEntryImpl中的readEntry方法中，对var0进行了readUTF()方法。 weblogic.wsee.workarea.WorkContextXmlInputAdapter.class 发现最终执行了readObject方法，对XMLDecoder对象进行了反序列化，导致了远程命令执行。 0x04 漏洞原因Weblogic没有对XML的数据进行任何的过滤，导致可以构造XML数据，通过反序列化任意对象，进行任意命令的执行，这就导致了CVE-2017-3506漏洞的产生。 0x05 Exploit暂无 0x06 后记参考网上现有复现资料的分析做出了分析报告，在第一次做漏洞复现的时候也踩了不少坑遇到了一些困难，感谢周围师傅们的帮忙和鼓励。第一次写复现博客，感觉自己在动手写分析是发现了一些没注意问题或者本来毫无概念性的东西，对于复现过程和漏洞都有较之前有了初步的了解，同时也深感自己知识能力有所欠缺，继续努力。 0x07 参考链接Weblogic XMLDecoder RCE分析 CVE-2017-10271 Weblogic XMLDecoder反序化分析 CVE-2017-3506 &amp; 10271：Weblogic 远程代码执行漏洞分析及复现笔记 Weblogic XMLDecoder RCE分析 从0开始学习WebLogic(Java)反序列化 (1)]]></content>
      <tags>
        <tag>Weblogic</tag>
        <tag>CVE</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下生成https证书]]></title>
    <url>%2Fposts%2Feb1c71d3.html</url>
    <content type="text"><![CDATA[环境准备基于windows平台64位系统 下载openssl 安装openssl有两种方式，第一种直接下载安装包，装上就可运行；第二种可以自己下载源码 此处的重点不是如何安装openssl,故选用最简单的方法进行使用： ​ Windows下的openssl的安装包下载地址为：openssl 生成证书安装好openssl之后进入到openssl的安装目录下的bin目录 默认路径为C:\Program Files\OpenSSL-Win64 运行一下命令，生成密钥key1openssl genrsa -des3 -out D:\workdir\server.key 2048 D:\Docker\docker-nginx-php-mysql\server.key:这个是生成的文件路径 这个命令执行的时候，会提示输入密码，任意输入即可 123456Generating RSA private key, 2048 bit long modulus (2 primes)....................................................................................................................................................+++++......+++++e is 65537 (0x010001)Enter pass phrase for D:\workdir\server.key:Verifying - Enter pass phrase for D:\workdir\server.key: 生成完毕后，可以使用以下命令移除密码： 1openssl rsa -in D:\workdir\server.key -out D:\workdir\server.key 创建证书的申请文件1openssl req -new -key D:\workdir\server.key -out D:\workdir\server.csr 如果在执行上面的命令的时候出现以下错误： 1Unable to load config info from /usr/local/ssl/openssl.cnf 此错误因为openssl找不到对应的配置文件，如果电脑已经安装过git的话，在git中已经存在这个文件夹，w文件默认路径为C:\Program Files\Git\mingw64\ssl\openssl.cnf我们可以借用git下面这个文件进行命令操作，可将命令修改为： 1openssl req -new -key D:\workdir\server.key -out D:\workdir\server.csr -config "C:\Program Files\Git\mingw64\ssl\openssl.cnf" 执行完上述命令后，根据提示一步步输入信息即可： 12345678910111213-----Country Name (2 letter code) [AU]:cnState or Province Name (full name) [Some-State]:*****Locality Name (eg, city) []:****Organization Name (eg, company) [Internet Widgits Pty Ltd]:personOrganizational Unit Name (eg, section) []:personCommon Name (e.g. server FQDN or YOUR name) []:personEmail Address []:*****8@example.comPlease enter the following 'extra' attributesto be sent with your certificate requestA challenge password []:An optional company name []: 后面的extra信息选填，可以直接回车略过。 签署服务器证书文件1openssl req -new -x509 -key D:\workdir\server.key -out D:\workdir\ca.crt -days 3650 -config "C:\Program Files\Git\mingw64\ssl\openssl.cnf" 注意：如果在之前出现过Unable to load config info from /usr/local/ssl/openssl.cnf，即找不到openssl的对应配置文件，需要在后面加上上述的-config参数；如果之前没有报错，可忽略掉-config参数。 使用上述文件创建自己的证书1openssl x509 -req -days 3650 -in D:\workdir\server.csr -CA D:\workdir\ca.crt -CAkey server.key -CAcreateserial -out D:\workdir\server.crt 至此，自签名的.crt生成完毕]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2Fposts%2Fb8f4bd70.html</url>
    <content type="text"><![CDATA[写在前面我使用的计算机为Windows平台，并以此为例，请确保在计算机上已经安装过Node.js和Git，然后在正确的路径执行以下命令： 1234npm install hexo-cli -g hexo init blog cd blog npm install 基本配置根据需要编辑文件_config.yml并应用自己的配置： 站点配置 1234567title: Tr4yv0n's Blogsubtitle:description:keywords: Programming,WebSec...etcauthor: Trayvonlanguage:zh-Hanstimezone: Asia/Shanghai URL配置 首先，安装依赖： 1npm install hexo-abbrlink --save 配置： 1234567url: http://yoursite.com root: / permalink: post/:abbrlink.htmlabbrlink: alg: crc32 # support crc16(default) and crc32 rep: hex # support dec(default) and hexpermalink_defaults: 部署配置 设置远程存储库。例如，创建您的GitHub页面。 在本地计算机上安装依赖项： 1npm install hexo-deployer-git --save 配置网站_config.yml 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 注意：需要将配置项中的repo更改为自己的仓库路径，且要注意每个配置选项的冒号后面要有一个空格，必要严格参照此规定格式，否则配置不会生效！！！ 请注意，要将博客部署到远程服务器，您必须具有用于编写访问权限的正确凭据。请参阅使用SSH连接到GitHub。 如果还想将博客部署到自己的Git服务器中，请参阅服务器上的Git - 设置服务器。 主题配置 首先，安装主题相关依赖： 1git clone https://github.com/theme-next/hexo-theme-next themes / next 配置： 在网站配置文件_config.yml 1theme: next NEXT主题相关配置根据需要编辑文件themes/next/_config.yml并应用自己的配置： 图标配置 访问https://realfavicongenerator.net并获取favicon。 配置主题： 123favicon： small: /favicon-16x16-next.png medium: /favicon-32x32-next.png 菜单配置 生成菜单页面 123hexo new page "tags"hexo new page "categories"hexo new page "about" 分别编辑他们的菜单： 123type: "tags"type: "categories"type: "about" 配置 12345menu: home: / || home about: /about/ || user categories: /categories/ || th archives: /archives/ || archive about页面可通过添加一些内容来自定义页面。 方案配置将其从Muse（默认方案）更改为Mist。 1scheme: Mist 社交链接配置123social: GitHub: https://github.com/PeichengLiu || github E-Mail: mailto:user@example.com || envelope 边栏头像12avatar: url: /avatar.jpg CC许可声明1reative_commons: by-nc-sa 本地搜索 首先，安装依赖项： 1npm install hexo-generator-searchdb --save 配置： 12local_search: enable: true 一些小操作内容压缩Gulp简介 gulp.js 是一种基于流的，代码优于配置的新一代构建工具。具体前往官网查看反正是一个基于 node 的用于自动化的工具，和 Grunt 比较类似，不过亮点是 流 和 写代码 ，所以会比 Grunt 快一点。 首先，安装依赖项： 1npm install gulp gulp-csso gulp-htmlmin gulp-htmlclean babel-core babel-preset-es2015 gulp-babel gulp-uglify --save-dev 创建一个gulpfile.js在博客根目录中命名的文件，然后将以下代码粘贴到其中： 12345678910111213141516171819202122232425262728293031323334const gulp = require('gulp');const csso = require('gulp-csso');const htmlmin = require('gulp-htmlmin');const htmlclean = require('gulp-htmlclean');const babel = require('gulp-babel');const uglify = require('gulp-uglify');gulp.task('minify-css', () =&gt; &#123; return gulp.src('./public/**/*.css') .pipe(csso()) .pipe(gulp.dest('./public'));&#125;);gulp.task('minify-js', () =&gt; &#123; return gulp.src(['./public/**/*.js', '!./public/**/*.min.js']) .pipe(babel(&#123; presets: ['es2015'] &#125;)) .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);gulp.task('minify-html', () =&gt; &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true &#125;)) .pipe(gulp.dest('./public'))&#125;);gulp.task('default', ['minify-css', 'minify-js', 'minify-html']); 在 hexo g 之后在 cmd 里敲入 gulp 回车就可以啦推荐姿势： 1hexo cl &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 更为推（偷）荐（懒）的方式：编辑名为package.json这样的文件 123456&#123; // ... pretend to be comments here, there is no syntax for comments in JSON "scripts": &#123; "publish": "hexo cl &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d" &#125;&#125; 从现在开始，就可以使用以下命令部署博客 1npm run publish 有关参考Hexo命令，npm-run-script，Gulp Tips:配置的时候遇到了个坑，多方查找后才解决了问题： 在配置webpack.config.js打包的时候,出现Error: Cannot find module &#39;@babel/core&#39;错误。 最初以为是babel-core没有安装上。重装了好几遍babel-core还是不行 官方默认babel-loader | babel 对应的版本需要一致: 即babel-loader需要搭配最新版本babel* 两种解决方案: 回退低版本 1npm install -D babel-loader@7 babel-core babel-preset-env 更新到最高版本: 1npm install -D babel-loader @babel/core @babel/preset-env webpack 参考资料：https://www.cnblogs.com/soyxiaobi/p/9554565.html 音乐播放器集成 在文件中附加以下代码themes/next/layout/_partials/footer.swig： 123&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" type="text/css"&gt;&lt;script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js"&gt;&lt;/script&gt; 按以下代码添加音乐到您的帖子： 1&lt;div class="aplayer" data-id="857619" data-server="netease" data-type="song" data-mode="single"&gt;&lt;/div&gt; 更多配置选项，请查看MetingJS。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
