<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阅读书目推荐]]></title>
    <url>%2Fposts%2F4f45247d.html</url>
    <content type="text"><![CDATA[写在前面:​ 平时一直有读书的习惯，去年大概读有87本书，一直没有去做产出和推荐，但每一本书多多少少都做有读书笔记,这带来的帮助超乎了我的预料。 ​ 既然老师上次提出了可以推荐书目的建议，我也觉得多读书确实大有裨益。绝不限于是课内书本以及专业课本，更希望能去广泛去涉猎经济，文化，政治等类目的书籍，会让我们更宏观且全面的去了解这个世界和社会中的既成规则以及现象，深入的了解自己。 ​ 这个事情我会根据我的阅读进度，不定期给大家进行更新推荐，也算是对我自己的一个勉励。 2019/4/1-2019/4/19​ 在此期间我看了大概有四本书吧，有的一部分书是高质量精读过去的： 《沉思录》——[古罗马]马可·奥勒留 《从0到1开启商业与未来的秘密》——[美]彼得·蒂尔 《大数据 : 正在到来的数据革命，以及它如何改变政府、商业与我们的生活》——[中]涂子沛 《爱与黑暗的故事》——[以色列] 阿摩司·奥兹 推荐书目： 1 《沉思录》 2 《从0到1开启商业与未来的秘密》 3 《大数据 : 正在到来的数据革命，以及它如何改变政府、商业与我们的生活》 推荐理由： ​ 简短几句话说一下推荐理由: 《沉思录》是古罗马皇帝奥勒留写给自己的书，内容大部分是他在鞍马劳顿中写成的。作品来自奥勒留对身羁宫廷的自己和自己所处混乱世界的感受，追求一种冷静而达观的生活。这部著作是斯多葛学派的一个里程碑。作品中处处反映出很多对于人生的感悟，引人深思，去追问内心和探索本我。其虽然成书于近两千年前的古罗马时期，但其中的内容时至今日都感觉内容深刻而富有哲理，适用于当今时代社会。 Paypal创始人，Facebook第一位外部投资者彼得•蒂尔在本书中详细阐述了自己的创业历程与心得，包括如何避免竞争、如何进行垄断、如何发现新的市场。《从0到1》还将带你穿越哲学、历史、经济等多元领域，解读世界运行的脉络，分享商业与未来发展的逻辑，帮助你思考从0到1的秘密，在意想不到之处发现价值与机会。对于无论是否有创业想法的我们开阔眼界都有很大的帮助。 本书通过讲述美国半个多世纪信息开放、技术创新的历史，以别开生面的经典案例——奥巴马建设“前所未有的开放政府”的雄心、公共财政透明的曲折、《数据质量法》背后的隐情、全民医改法案的波澜、统一身份证的百年纠结、街头警察的创新传奇、美国矿难的悲情历史、商务智能的前世今生、数据开放运动的全球兴起，以及云计算、Facebook和推特等社交媒体、Web3.0与下一代互联网的未来图景等等，为您一一细解，数据创新给公民、政府、社会带来的种种挑战和变革。 美国是全书主体，但又处处反观中国当下的现实。回望中国，胡适批评“差不多先生”，黄仁宇求索“数目字管理”，作者从太平洋对面看到中美两国的差距，深知中国缺少什么、需要什么，故将十多年观察、思索所得，淘洗成这一本书。 史学大家、匹兹堡大学历史系荣誉讲座教授许倬云，有感于“老大哥”的影子，专门作序：“我们要对涂子沛先生致敬与致谢，因为他为华文世界提出一个重要的话题。” 哈佛大学商学院访问教授、全球顶尖的管理咨询大师达文波特，为中国政经两界提示智库建言：“无论是对中国政府，还是就中国的商业组织而言，《大数据》都是一本重要的书。” ​ 最后说一下为什么没有推荐第四本书，《爱与黑暗的故事》这本书讲述的是百余年间一个犹太家族的历史与民族叙事，文笔很棒，但出于文化的差异，对于以色列文化以及当时的时代背景自己缺乏一定的了解，以至于在阅读的时候有很多的不理解和提不起兴趣，缺乏知识共鸣，但作者的文笔和作品底蕴在世界上都是一流的，后期有补充犹太史和以色列文化的打算，再来拜读这本书，此前有这些基础的同学很推荐阅读这本书。 2019/4/19-]]></content>
      <tags>
        <tag>书籍推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在http层通过header请求头伪造ip]]></title>
    <url>%2Fposts%2F56dbd93c.html</url>
    <content type="text"><![CDATA[前言在正常的tcp/ip协议中是很难伪造ip的，因为在tcp/ip正式通信之前是有一个三次握手的过程，通过三次握手建立了tcp/ip连接之后再进行正常的通信，所以我之前想用python的scapy库来伪造其他ip的请求包，但是因为三次握手的时候，我的ip是伪造的，我发出去的请求包就没有办法正确的返回找到我，所以无法三次握手就没有tcp/ip正常通信，就失败了。 只要能够在tcp/ip层伪造ip，就是完全的伪造ip，没有任何办法判断，不过我这次的是在http层伪造ip，所以还是可能被发现的，而且也只有在http协议中有用，无法利用在其他地方。 header那么如何在http层伪造协议呢？我们先来了解一些http请求中的请求头header，比如说我们在chrome中登陆百度，打开chrome的开发者工具，查看network，就能够看到这次请求百度的header请求头。 Requests Headers 12345678Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding:gzip, deflate, sdchAccept-Language:zh-CN,zh;q=0.8Connection:keep-aliveCookie:BIDUPSID=XXX; PSTM=XXX; BAIDUID=XXX:FG=1; BDUSS=XXX; __cfduid=XXX; ispeed_lsm=2; BD_HOME=1; BDRCVFR[Ups602knC30]=XXX; BD_CK_SAM=1; H_PS_PSSID=XXX; BD_UPN=XXX; H_PS_645EC=XXX; locale=XXX; BDSVRTM=0; BD_LAST_QID=XXXHost:www.baidu.comUpgrade-Insecure-Requests:1User-Agent:Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/49.0.2623.108 Chrome/49.0.2623.108 Safari/537.36 可以看到这里有很多的请求参数，在我们打开百度的时候，我们先要向百度服务器发送一个请求，而这个请求包含很多附加的关于我们自己的信息，比如说浏览器信息，cookie，接受数据格式等等，百度服务器收到我们的请求之后，返回给我们百度的页面。 在我们发送http请求之前，就已经先进行了tcp/ip三次握手，然后再发送http请求，三次握手的过程是非常迅速的，可以用抓包工具 wireshark 查看。 所以 header 请求头主要是一些我们发送请求时附带的我们自己的信息，同时，在看到 header 请求头的时候，也会发现在服务器返回数据的时候也会带有一个 header ，这是返回数据格式的一些信息，包括返回数据的格式，大小，时间等。 可尝试各种伪造IP的HTTP头： 12345X-Forwarded-ForClient-IPx-remote-IPx-originating-IPx-remote-addr X-Forwarded-For接下来就是我们伪造ip的核心了，header 请求头中的 X-Forwarded-For 参数 ，这是一个用来识别http代理或负载平衡的原始ip的一个非rfc标准，就是在http请求中有时会使用代理，或者是负载均衡的时候通过了一个转发，这样的话原始ip就被隐藏起来了，这个参数就是为了标注出原始ip，格式是X-Forwarded-For:client1, proxy1, proxy2 ... 第一个是原始ip，后面是经过的代理。 本来这个参数是挺好的，可以判断你是否经过代理判断原始ip，不过一般使用代理的人不就是为了不被别人发现自己的真实ip么？所以这个参数也没用成为rfc的标准，默认是没有的，不强制添加。 所以这样的话，我们本来没有使用代理，就是真实ip，是不是就可以通过增加一个这样的 header 参数来伪造自己经过了代理呢？然后加入我们伪造的 ip ，让服务器以为它是真实的ip。 这样的一个思路看起来是挺好的，那么接下来我们看一下服务器是如何得到我们的ip的。 服务器如何得到客户ip的在这里以php为例，在php里有三个值保存客户ip，分别是 HTTP_CLIENT_IP,HTTP_X_FORWARDED_FOR,REMOTE_ADDR 。 $_SERVER[&#39;HTTP_CLIENT_IP&#39;] 如果有代理服务器，一般是代理服务器ip，没有则为空$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;] 如果有代理服务器的话，一般是原始ip，没有则为空，若有多个则也显示代理服务器ip $_SERVER[&#39;REMOTE_ADDR&#39;] 如果有代理服务器的话，则为最后一个代理的ip，没有则为连接的客户端ip 可以看到有很多的一般，也就是说前两个都是可以伪造的，最后的一个倒是很难伪造，不过如果真的有代理的话，最后一个也没有什么用。 所以，如何得到真实的客户端ip也是一个很头疼的问题，现在一般的做法是先取得 $_SERVER[&#39;REMOTE_ADDR&#39;] 然后再判断有没有代理，如果有代理则获得原始ip，如果有，则将原始ip作为客户端的ip，比如说采用这种做法的有discuz。 在 discuz 的当前最新版 X3.2 中，可以在 /source/class/discuz/discuz_application.php中找到其获取客户端ip的函数 _get_client_ip ,函数如下。 1234567891011121314private function _get_client_ip() &#123; $ip = $_SERVER['REMOTE_ADDR']; if (isset($_SERVER['HTTP_CLIENT_IP']) &amp;&amp; preg_match('/^([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;$/', $_SERVER['HTTP_CLIENT_IP'])) &#123; $ip = $_SERVER['HTTP_CLIENT_IP']; &#125; elseif(isset($_SERVER['HTTP_X_FORWARDED_FOR']) AND preg_match_all('#\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;#s', $_SERVER['HTTP_X_FORWARDED_FOR'], $matches)) &#123; foreach ($matches[0] AS $xip) &#123; if (!preg_match('#^(10|172\.16|192\.168)\.#', $xip)) &#123; $ip = $xip; break; &#125; &#125; &#125; return $ip;&#125; 也有用这样的函数来取得客户端的ip，不过想法都是一样的，只是实现不一样。 1234567891011function GetIP()&#123; if(!empty($_SERVER["HTTP_CLIENT_IP"])) $cip = $_SERVER["HTTP_CLIENT_IP"] else if(!empty($_SERVER["HTTP_X_FORWARDED_FOR"])) $cip = $_SERVER["HTTP_X_FORWARDED_FOR"] else if(!empty($_SERVER["REMOTE_ADDR"])) $cip = $_SERVER["REMOTE_ADDR"] else $cip = "无法获取！"; return $cip;&#125; 总结测试了一下使用 discuz 的情况，确实是可以伪造ip的，特别是在使用discuz插件投票的时候，可以恶意刷票，不过为了防止这种情况的发生，在服务器端可以通过设置服务器来过滤，这里就不再展开详叙了。 转载出处：通过修改http请求的header请求头来伪造ip By Windard]]></content>
      <tags>
        <tag>web</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YFCTFwriteup]]></title>
    <url>%2Fposts%2F2308731.html</url>
    <content type="text"><![CDATA[YFCTF 部分writeup 但行好事，莫问前程 目标依然存在，把它模糊化成心中一盏明灯，指引前行的北斗星 第一次写正式写writeup，写出已经做出答案题目的writeup，希望自己但凡做一件事都能坚持下去 0x01隐写算是常规套路，折腾了会儿图片发现没什么东西，然后用audacity打开音频文件。适当放大后可以看出来是摩斯密码，使用http://ctf.ssleye.com/解密工具可以直接解密出来。 1flag&#123;jygg&#125; 0x02兵器1024所这是一道流量分析题，先用wireshark打开附件，得到报文： 没有思路的时候从开始逐个点开查看内容，由于主办方的flag为flag{…}的格式，在查看中发现第1，3，5，7的包中恰好有这几个keywords，且全部是request发出的包，所以注重观察request发出的包。 经过对应后，发现将报文中request发出的包中的ttl值当做十进制处理，对应ASCII表后即为所求，得到： 1flag&#123;fkdsjaklvklfnkvhcihvekjndjkschsja&#125; 0x03不安全的上传这道题本来分析报文分析了挺久都没有头绪，以为找的了flag试了下都是错的，在伙伴的提醒下，看了下题目：不安全的上传，结合报文内容找到了与之相关的ftp协议，在窗口顶端过滤栏输入并点击Apply，着重分析ftp协议的内容： 通过对内容观察可知，使用者使用ftp协议进行了两次尝试登录，第一次登录失败，第二次登陆成功，所以flag是第二次登陆信息的可能大一些，进行尝试提交后通过。 1flag&#123;wfjhds$ghrewjgnds%chsjgre&#125; 0x04杂项加密这道题做的时候在尝试理解加密方式，也没查到是哪种加密方式(还是见得太少了)，最后在伙伴的提醒下知道是古典密码的仿射密码： 原理 wiki 仿射密码的加密函数是$$E(x)=(ax+b)(modm)E(x)=(ax+b)(modm)$$其中 xx 表示明文按照某种编码得到的数字 aa 和 mm 互质 mm 是编码系统中字母的数目。 根基观察发现，虽然对于 flag 中的每个字母都加密了 n 次，如果我们仔细分析的话，我们可以发现$$c_1=a_1c+b_1$$ $$c_2=a_2c_1+b_2 =a_1a_2c+a_2b_1+b_2 =kc+d$$ 根据第二行的推导，我们可以得到其实 cncn 也是这样的形式，可以看成 cn=xc+ycn=xc+y ，并且，我们可以知道的是，key 是始终不变化的，所以说，其实这个就是仿射密码。 根据原理利用明文进行攻击： 1234567891011121314151617import gmpykey = '****CENSORED****************'flag = 'TWCTF&#123;*******CENSORED********&#125;'f = open('encrypted', 'r')data = f.read().strip('\n')encrypted = [int(data[i:i + 2], 16) for i in range(0, len(data), 2)]plaindelta = ord(flag[1]) - ord(flag[0])cipherdalte = encrypted[1] - encrypted[0]a = gmpy.invert(plaindelta, 251) * cipherdalte % 251b = (encrypted[0] - a * ord(flag[0])) % 251a_inv = gmpy.invert(a, 251)result = ""for c in encrypted: result += chr((c - b) * a_inv % 251)print result 0x05后记这是自己第二次参加CTF比赛，每一次的比赛中都能真真切切的感受到自己的菜，还是见的太少。自己做出来的题不多，赛后做出的题目由于不知道对错，就没有写出来，题目平台关的这么快有些难受。但好在不断的在朝前走，每一次都能有所收获。下来需要合理安排自己的时间。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weblogic反序列化漏洞初探]]></title>
    <url>%2Fposts%2F669570ad.html</url>
    <content type="text"><![CDATA[Weblogic由WLS Security子组件对外部提供Webservice服务，其中使用了XMLDecoder来解析用户传入的数据，在解析过程中间出现反序列化漏洞，导致可以进行任意命令的执行，由此导致了CVE-2017-3506 &amp; CVE-2017-10271的产生。 0x00 环境准备 Windows 10 x64 Docker CE for Windows IntelliJ IDEA 在Github上的Vulhub是一个面向大众的开源漏洞靶场，因此可以利用现成的Vulhub中的docker-compose.yml进行环境搭建，具体操作步骤可以参照Vulhub相应的描述文件，内容十分详尽，感谢Vulhub大佬们的贡献，为萌新剩下了不少造轮子的时间。 由于需要在宿主机进行本地调试，除了本来打开的7001端口之外，还需要开放一个远端调试端口，所以应该改动一下docker-compose.yml开放8453端口，修改完的内容如下 1234567version: &apos;2&apos;services: weblogic: image: vulhub/weblogic ports: - &quot;7001:7001&quot; - &quot;8453:8453&quot; 启动镜像中间我个人碰到了一些奇怪的问题，导致端口一直打不开，最后发现将配置文件修改如下后，镜像启动正常,很迷。 1234567version: '2'services: weblogic: image: vulhub/weblogic ports: - 7001:7001 - 8453:8453 最后在Docker中docker-compose up -d完成搭建。 Docker搭建完成后，使用命令docker exec -it weblogic bash进入docker容器，修改/root/Oracle/Middleware/user_projects/domains/base_domain/bin/setDomainEnv.sh文件，找到以下代码段 12345if [ "$&#123;debugFlag&#125;" = "true" ] ; then JAVA_DEBUG="-Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,address=$&#123;DEBUG_PORT&#125;,server=y,suspend=n -Djava.compiler=NONE" export JAVA_DEBUG JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; $&#123;enableHotswapFlag&#125; -ea -da:com.bea... -da:javelin... -da:weblogic... -ea:com.bea.wli... -ea:com.bea.broker... -ea:com.bea.sbconsole..." export JAVA_OPTIONS 在其前面添加： 12debugFlag="true"expport debugFlag 运行exit退出容器，重启容器。使用命令docker ps查看容器运行情况。 由于要在宿主机远程调试Weblogic，而weblogic是没有源码的，所以需要把相关依赖也一并拷出来。 docker cp weblogic:/root/Oracle/Middleware/wlserver_10.3 ./wlserver_10.3 但会报出如下错误： 1open D:\Docker\vulhub\weblogic\CVE-2017-10271\wlserver_10.3\samples\server\medrec\modules\physician\assembly\target\exploded\physician\physician-jaxrpc-facade-client-broker\WEB-INF\classes\com\bea\physician\facade\broker\jaxrpc\JaxRpcRecordCreationFacadeClientBroker.class: The system cannot find the path specified. 查找结果如下： 由于微软对于命令行下的路径长度限制，拷贝行为会报错并结束。 可以使用linux打包命令：zip -r zipname.zip /targetdir 1zip -r wlserver_10.3.zip /wlserver_10.3 这部分jar包不全，还要将Docker中，/root/Oracle/Middleware/modules给拷出来，然后全部扔进刚才复制到宿主机的wlserver_10.3/server/lib目录下。 0x01 远程调试使用idea打开wlserver_10.3，将server/lib文件夹添加到library。 添加完后，就会发现里面的.jar和.war的包都可以点开了。并且可以搜索里面的一些类和字符串了。然后设置debug，添加一个Remote配置： 端口设置为8453，并且设置module classpath： 点击debug，出现如下字样，说明已经配置ok。 在wlserver_10.3/server/lib/weblogic.jar!/weblogic/wsee/jaxws/WLSServletAdapter.class中的handle方法下断点，看看能否击中断点。 0x02 漏洞复现测试使用的POC如下： 1234567891011121314151617181920212223242526POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: 127.0.0.1:7001Cache-Control: max-age=0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36Upgrade-Insecure-Requests: 1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7Connection: closeContent-Type: text/xmlContent-Length: 769&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/"&gt; &lt;java&gt; &lt;void class="java.lang.ProcessBuilder"&gt; &lt;array class="java.lang.String" length="3"&gt; 。。。。 &lt;void method="start"/&gt; &lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; 对于poc中uri中/wls-wsat/CoordinatorPortType 可以换成CoordinatorPortType11等wsat 这个webservice服务中存在的其他uri。 由于在docker中，就只是利用权限进行了文件写入。 执行的效果图如下： 0x03 动态分析根据poc内容可知，此次漏洞出现在wls-wsat.war中，构造SOAP（XML）格式的请求，在解析的过程中导致XMLDecoder反序列化漏洞 在IDEA中搜索wls-wsat.war。打开后点击web.xml查看有哪些接口 第一个就是所需要的接口。由于WebLogic servlet的分发机制复杂，先放在一边。 根据网上大佬们已有分析，我只是跟一下流程： 从processRequest开始被xml逻辑处理，输入中的readUTF中被反序列化。以下是函数调用栈： 具体分析流程如下：weblogic.wsee.jaxws.WLSServletAdapter.class 请求先会进入handel方法，handel方法又会执行super.handle(var1, var2, var3);方法，这个方法对servlet的容器和request和response进行了封装。 继续跟进 先会对var1的内容判断是否为空，不为空的话，会取出xml中的header，也就是我们poc中的: weblogic.wsee.jaxws.workcontext.WorkContextTube 继续跟进receive() weblogic.workarea.WorkContextMapImpl 将数据传到下一个receiveRequest。 weblogic.workarea.WorkContextLocalMap WorkContextEntryImpl.readEntry(var1)对传进来的数据进行处理，继续跟进 weblogic.workarea.spi.WorkContextEntryImpl 继续跟进WorkContextEntryImpl中的readEntry方法中，对var0进行了readUTF()方法。 weblogic.wsee.workarea.WorkContextXmlInputAdapter.class 发现最终执行了readObject方法，对XMLDecoder对象进行了反序列化，导致了远程命令执行。 0x04 漏洞原因Weblogic没有对XML的数据进行任何的过滤，导致可以构造XML数据，通过反序列化任意对象，进行任意命令的执行，这就导致了CVE-2017-3506漏洞的产生。 0x05 Exploit暂无 0x06 后记参考网上现有复现资料的分析做出了分析报告，在第一次做漏洞复现的时候也踩了不少坑遇到了一些困难，感谢周围师傅们的帮忙和鼓励。第一次写复现博客，感觉自己在动手写分析是发现了一些没注意问题或者本来毫无概念性的东西，对于复现过程和漏洞都有较之前有了初步的了解，同时也深感自己知识能力有所欠缺，继续努力。 0x07 参考链接Weblogic XMLDecoder RCE分析 CVE-2017-10271 Weblogic XMLDecoder反序化分析 CVE-2017-3506 &amp; 10271：Weblogic 远程代码执行漏洞分析及复现笔记 Weblogic XMLDecoder RCE分析 从0开始学习WebLogic(Java)反序列化 (1)]]></content>
      <tags>
        <tag>Weblogic</tag>
        <tag>CVE</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下生成https证书]]></title>
    <url>%2Fposts%2Feb1c71d3.html</url>
    <content type="text"><![CDATA[环境准备基于windows平台64位系统 下载openssl 安装openssl有两种方式，第一种直接下载安装包，装上就可运行；第二种可以自己下载源码 此处的重点不是如何安装openssl,故选用最简单的方法进行使用： ​ Windows下的openssl的安装包下载地址为：openssl 生成证书安装好openssl之后进入到openssl的安装目录下的bin目录 默认路径为C:\Program Files\OpenSSL-Win64 运行一下命令，生成密钥key1openssl genrsa -des3 -out D:\workdir\server.key 2048 D:\Docker\docker-nginx-php-mysql\server.key:这个是生成的文件路径 这个命令执行的时候，会提示输入密码，任意输入即可 123456Generating RSA private key, 2048 bit long modulus (2 primes)....................................................................................................................................................+++++......+++++e is 65537 (0x010001)Enter pass phrase for D:\workdir\server.key:Verifying - Enter pass phrase for D:\workdir\server.key: 生成完毕后，可以使用以下命令移除密码： 1openssl rsa -in D:\workdir\server.key -out D:\workdir\server.key 创建证书的申请文件1openssl req -new -key D:\workdir\server.key -out D:\workdir\server.csr 如果在执行上面的命令的时候出现以下错误： 1Unable to load config info from /usr/local/ssl/openssl.cnf 此错误因为openssl找不到对应的配置文件，如果电脑已经安装过git的话，在git中已经存在这个文件夹，w文件默认路径为C:\Program Files\Git\mingw64\ssl\openssl.cnf我们可以借用git下面这个文件进行命令操作，可将命令修改为： 1openssl req -new -key D:\workdir\server.key -out D:\workdir\server.csr -config "C:\Program Files\Git\mingw64\ssl\openssl.cnf" 执行完上述命令后，根据提示一步步输入信息即可： 12345678910111213-----Country Name (2 letter code) [AU]:cnState or Province Name (full name) [Some-State]:*****Locality Name (eg, city) []:****Organization Name (eg, company) [Internet Widgits Pty Ltd]:personOrganizational Unit Name (eg, section) []:personCommon Name (e.g. server FQDN or YOUR name) []:personEmail Address []:*****8@example.comPlease enter the following 'extra' attributesto be sent with your certificate requestA challenge password []:An optional company name []: 后面的extra信息选填，可以直接回车略过。 签署服务器证书文件1openssl req -new -x509 -key D:\workdir\server.key -out D:\workdir\ca.crt -days 3650 -config "C:\Program Files\Git\mingw64\ssl\openssl.cnf" 注意：如果在之前出现过Unable to load config info from /usr/local/ssl/openssl.cnf，即找不到openssl的对应配置文件，需要在后面加上上述的-config参数；如果之前没有报错，可忽略掉-config参数。 使用上述文件创建自己的证书1openssl x509 -req -days 3650 -in D:\workdir\server.csr -CA D:\workdir\ca.crt -CAkey server.key -CAcreateserial -out D:\workdir\server.crt 至此，自签名的.crt生成完毕]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2Fposts%2Fb8f4bd70.html</url>
    <content type="text"><![CDATA[写在前面我使用的计算机为Windows平台，并以此为例，请确保在计算机上已经安装过Node.js和Git，然后在正确的路径执行以下命令： 1234npm install hexo-cli -g hexo init blog cd blog npm install 基本配置根据需要编辑文件_config.yml并应用自己的配置： 站点配置 1234567title: Tr4yv0n's Blogsubtitle:description:keywords: Programming,WebSec...etcauthor: Trayvonlanguage:zh-Hanstimezone: Asia/Shanghai URL配置 首先，安装依赖： 1npm install hexo-abbrlink --save 配置： 1234567url: http://yoursite.com root: / permalink: post/:abbrlink.htmlabbrlink: alg: crc32 # support crc16(default) and crc32 rep: hex # support dec(default) and hexpermalink_defaults: 部署配置 设置远程存储库。例如，创建您的GitHub页面。 在本地计算机上安装依赖项： 1npm install hexo-deployer-git --save 配置网站_config.yml 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 注意：需要将配置项中的repo更改为自己的仓库路径，且要注意每个配置选项的冒号后面要有一个空格，必要严格参照此规定格式，否则配置不会生效！！！ 请注意，要将博客部署到远程服务器，您必须具有用于编写访问权限的正确凭据。请参阅使用SSH连接到GitHub。 如果还想将博客部署到自己的Git服务器中，请参阅服务器上的Git - 设置服务器。 主题配置 首先，安装主题相关依赖： 1git clone https://github.com/theme-next/hexo-theme-next themes / next 配置： 在网站配置文件_config.yml 1theme: next NEXT主题相关配置根据需要编辑文件themes/next/_config.yml并应用自己的配置： 图标配置 访问https://realfavicongenerator.net并获取favicon。 配置主题： 123favicon： small: /favicon-16x16-next.png medium: /favicon-32x32-next.png 菜单配置 生成菜单页面 123hexo new page "tags"hexo new page "categories"hexo new page "about" 分别编辑他们的菜单： 123type: "tags"type: "categories"type: "about" 配置 12345menu: home: / || home about: /about/ || user categories: /categories/ || th archives: /archives/ || archive about页面可通过添加一些内容来自定义页面。 方案配置将其从Muse（默认方案）更改为Mist。 1scheme: Mist 社交链接配置123social: GitHub: https://github.com/PeichengLiu || github E-Mail: mailto:user@example.com || envelope 边栏头像12avatar: url: /avatar.jpg CC许可声明1reative_commons: by-nc-sa 本地搜索 首先，安装依赖项： 1npm install hexo-generator-searchdb --save 配置： 12local_search: enable: true 一些小操作内容压缩Gulp简介 gulp.js 是一种基于流的，代码优于配置的新一代构建工具。具体前往官网查看反正是一个基于 node 的用于自动化的工具，和 Grunt 比较类似，不过亮点是 流 和 写代码 ，所以会比 Grunt 快一点。 首先，安装依赖项： 1npm install gulp gulp-csso gulp-htmlmin gulp-htmlclean babel-core babel-preset-es2015 gulp-babel gulp-uglify --save-dev 创建一个gulpfile.js在博客根目录中命名的文件，然后将以下代码粘贴到其中： 12345678910111213141516171819202122232425262728293031323334const gulp = require('gulp');const csso = require('gulp-csso');const htmlmin = require('gulp-htmlmin');const htmlclean = require('gulp-htmlclean');const babel = require('gulp-babel');const uglify = require('gulp-uglify');gulp.task('minify-css', () =&gt; &#123; return gulp.src('./public/**/*.css') .pipe(csso()) .pipe(gulp.dest('./public'));&#125;);gulp.task('minify-js', () =&gt; &#123; return gulp.src(['./public/**/*.js', '!./public/**/*.min.js']) .pipe(babel(&#123; presets: ['es2015'] &#125;)) .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);gulp.task('minify-html', () =&gt; &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true &#125;)) .pipe(gulp.dest('./public'))&#125;);gulp.task('default', ['minify-css', 'minify-js', 'minify-html']); 在 hexo g 之后在 cmd 里敲入 gulp 回车就可以啦推荐姿势： 1hexo cl &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 更为推（偷）荐（懒）的方式：编辑名为package.json这样的文件 123456&#123; // ... pretend to be comments here, there is no syntax for comments in JSON "scripts": &#123; "publish": "hexo cl &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d" &#125;&#125; 从现在开始，就可以使用以下命令部署博客 1npm run publish 有关参考Hexo命令，npm-run-script，Gulp Tips:配置的时候遇到了个坑，多方查找后才解决了问题： 在配置webpack.config.js打包的时候,出现Error: Cannot find module &#39;@babel/core&#39;错误。 最初以为是babel-core没有安装上。重装了好几遍babel-core还是不行 官方默认babel-loader | babel 对应的版本需要一致: 即babel-loader需要搭配最新版本babel* 两种解决方案: 回退低版本 1npm install -D babel-loader@7 babel-core babel-preset-env 更新到最高版本: 1npm install -D babel-loader @babel/core @babel/preset-env webpack 参考资料：https://www.cnblogs.com/soyxiaobi/p/9554565.html 音乐播放器集成 在文件中附加以下代码themes/next/layout/_partials/footer.swig： 123&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" type="text/css"&gt;&lt;script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js"&gt;&lt;/script&gt; 按以下代码添加音乐到您的帖子： 1&lt;div class="aplayer" data-id="857619" data-server="netease" data-type="song" data-mode="single"&gt;&lt;/div&gt; 更多配置选项，请查看MetingJS。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
